---
title: "TAMUctf 2021 Encoding Solution"
slug: "tamuctf-2021-encoding-writeup"
date: "2021-04-26 11:39:00.000000"
author_name: "Javantea"
author_email: "jvoss@altsci.com"
draft: false
toc: false
images:
---

TAMUctf 2021
[Encoding](https://ctftime.org/task/15793) - 100 points

>    This is literally the flag but obfuscated through tons of different encoding schemes. [data.txt](https://shell.tamuctf.com/static/a60c1bd056ebe6d12577d3999a471e34/data.txt)

Step 1: Convert from a string of integers separated by spaces to a list of integers.

```python
a = open('encoding_data.txt', 'r').read()
b = [chr(int(x)) for x in a.split()]
b = [int(x) for x in a.split()]
c = bytes(b)

```

Step 2: Try to see if it's using UTF-16.

```python
c.decode('utf-16')
'ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㴿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㴿ꪆ㴿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㴿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㴿ꪆ㴿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㴿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㴿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㴿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㰿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㴿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㴿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㴿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㴿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㴿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㴿ꪆ㴿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㴿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㴿ꪆ㴿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㴿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㴿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㴿ꪆ㴿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㴿ꪆ㴿ꪆ㴿ꪆ㰿ꪆ㴿ꪆ㰿ꪆ㰿ꪆ㴿ꪆ㴿ꪆ㴿ꪆ㴿ꪆ㰿ꪆ㴿'

c.decode('utf-16be')
'蚪㼼蚪㼽蚪㼼蚪㼼蚪㼽蚪㼽蚪㼼蚪㼼蚪㼼蚪㼽蚪㼼蚪㼼蚪㼽蚪㼼蚪㼼蚪㼽蚪㼼蚪㼽蚪㼼蚪㼽蚪㼽蚪㼼蚪㼽蚪㼼蚪㼼蚪㼽蚪㼼蚪㼼蚪㼼蚪㼽蚪㼽蚪㼽蚪㼼蚪㼽蚪㼼蚪㼽蚪㼽蚪㼼蚪㼼蚪㼽蚪㼼蚪㼼蚪㼽蚪㼽蚪㼼蚪㼼蚪㼽蚪㼽蚪㼼蚪㼽蚪㼼蚪㼽蚪㼼蚪㼼蚪㼽蚪㼽蚪㼼蚪㼼蚪㼽蚪㼽蚪㼼蚪㼼蚪㼽蚪㼼蚪㼼蚪㼽蚪㼼蚪㼼蚪㼽蚪㼼蚪㼽蚪㼽蚪㼼蚪㼼蚪㼽蚪㼽蚪㼼蚪㼽蚪㼼蚪㼼蚪㼼蚪㼽蚪㼼蚪㼽蚪㼽蚪㼼蚪㼼蚪㼽蚪㼼蚪㼽蚪㼼蚪㼽蚪㼼蚪㼽蚪㼼蚪㼼蚪㼼蚪㼽蚪㼼蚪㼼蚪㼽蚪㼽蚪㼽蚪㼽蚪㼼蚪㼽蚪㼼蚪㼽蚪㼼蚪㼽蚪㼼蚪㼼蚪㼼蚪㼽蚪㼼蚪㼼蚪㼽蚪㼼蚪㼽蚪㼼蚪㼼蚪㼽蚪㼼蚪㼽蚪㼼蚪㼼蚪㼽蚪㼽蚪㼼蚪㼽蚪㼼蚪㼼蚪㼼蚪㼽蚪㼽蚪㼽蚪㼼蚪㼽蚪㼼蚪㼽蚪㼼蚪㼽蚪㼽蚪㼼蚪㼼蚪㼽蚪㼼蚪㼽蚪㼼蚪㼽蚪㼽蚪㼼蚪㼼蚪㼽蚪㼼蚪㼼蚪㼼蚪㼽蚪㼼蚪㼽蚪㼼蚪㼼蚪㼽蚪㼽蚪㼼蚪㼼蚪㼽蚪㼼蚪㼼蚪㼽蚪㼼蚪㼽蚪㼼蚪㼼蚪㼽蚪㼼蚪㼼蚪㼼蚪㼽蚪㼽蚪㼼蚪㼼蚪㼽蚪㼼蚪㼼蚪㼽蚪㼼蚪㼽蚪㼼蚪㼼蚪㼽蚪㼽蚪㼼蚪㼽蚪㼼蚪㼼蚪㼽蚪㼽蚪㼽蚪㼽蚪㼼蚪㼽蚪㼼蚪㼼蚪㼼蚪㼼蚪㼽蚪㼼蚪㼼蚪㼽蚪㼼蚪㼽蚪㼼蚪㼼蚪㼽蚪㼼蚪㼼蚪㼽蚪㼼蚪㼼蚪㼼蚪㼽蚪㼽蚪㼽蚪㼼蚪㼼蚪㼽蚪㼽蚪㼼蚪㼼蚪㼽蚪㼼蚪㼼蚪㼽蚪㼼蚪㼽蚪㼽蚪㼼蚪㼽蚪㼼蚪㼼蚪㼽蚪㼼蚪㼼蚪㼼蚪㼽蚪㼼蚪㼼蚪㼼蚪㼽蚪㼼蚪㼼蚪㼼蚪㼽蚪㼽蚪㼽蚪㼼蚪㼽蚪㼼蚪㼼蚪㼽蚪㼼蚪㼽蚪㼼蚪㼼蚪㼽蚪㼼蚪㼽蚪㼼蚪㼽蚪㼽蚪㼼蚪㼼蚪㼽蚪㼼蚪㼼蚪㼽蚪㼽蚪㼼蚪㼽蚪㼼蚪㼽蚪㼼蚪㼼蚪㼼蚪㼽蚪㼼蚪㼽蚪㼼蚪㼼蚪㼽蚪㼽蚪㼼蚪㼽蚪㼼蚪㼼蚪㼼蚪㼽蚪㼼蚪㼽蚪㼽蚪㼼蚪㼽蚪㼼蚪㼼蚪㼽蚪㼼蚪㼽蚪㼼蚪㼽蚪㼼蚪㼼蚪㼼蚪㼽蚪㼼蚪㼼蚪㼼蚪㼼蚪㼽蚪㼽蚪㼼蚪㼽蚪㼼蚪㼼蚪㼽蚪㼽蚪㼽蚪㼼蚪㼼蚪㼽蚪㼼蚪㼼蚪㼽蚪㼼蚪㼽蚪㼼蚪㼼蚪㼽蚪㼼蚪㼼蚪㼼蚪㼼蚪㼽蚪㼼蚪㼼蚪㼽蚪㼼蚪㼼蚪㼼蚪㼽蚪㼼蚪㼼蚪㼼蚪㼽蚪㼼蚪㼼蚪㼼蚪㼼蚪㼼蚪㼽蚪㼼蚪㼽蚪㼼蚪㼽蚪㼼蚪㼽蚪㼽蚪㼽蚪㼼蚪㼽蚪㼼蚪㼼蚪㼼蚪㼼蚪㼽蚪㼼蚪㼼蚪㼽蚪㼼蚪㼽蚪㼼蚪㼼蚪㼽蚪㼽蚪㼼蚪㼽蚪㼼蚪㼼蚪㼽蚪㼼蚪㼽蚪㼼蚪㼼蚪㼽蚪㼼蚪㼽蚪㼽蚪㼼蚪㼽蚪㼼蚪㼼蚪㼼蚪㼽蚪㼽蚪㼼蚪㼽蚪㼼蚪㼼蚪㼼蚪㼽蚪㼼蚪㼽蚪㼼蚪㼽蚪㼽蚪㼽蚪㼼蚪㼽蚪㼼蚪㼼蚪㼽蚪㼼蚪㼽蚪㼽蚪㼼蚪㼽蚪㼼蚪㼽蚪㼼蚪㼽蚪㼽蚪㼽蚪㼼蚪㼽蚪㼼蚪㼼蚪㼼蚪㼼蚪㼽蚪㼽蚪㼼蚪㼽蚪㼼蚪㼼蚪㼼蚪㼼蚪㼽蚪㼽蚪㼼蚪㼽蚪㼼蚪㼼蚪㼼蚪㼽蚪㼽蚪㼽蚪㼼蚪㼽蚪㼼蚪㼼蚪㼼蚪㼼蚪㼽蚪㼼蚪㼼蚪㼽蚪㼼蚪㼼蚪㼼蚪㼽蚪㼽蚪㼽蚪㼼蚪㼽蚪㼼蚪㼽蚪㼼蚪㼽蚪㼼蚪㼽蚪㼼蚪㼽蚪㼼蚪㼼蚪㼽蚪㼽蚪㼼蚪㼽蚪㼼蚪㼽蚪㼼蚪㼼蚪㼽蚪㼽蚪㼽蚪㼽蚪㼼蚪㼽蚪㼼蚪㼼蚪㼼蚪㼼蚪㼽蚪㼼蚪㼼蚪㼽蚪㼼蚪㼽蚪㼼蚪㼼蚪㼼蚪㼽蚪㼼蚪㼽蚪㼼蚪㼼蚪㼽蚪㼼蚪㼽蚪㼼蚪㼼蚪㼽蚪㼼蚪㼽蚪㼼蚪㼽蚪㼽蚪㼼蚪㼼蚪㼽蚪㼼蚪㼽蚪㼼蚪㼽蚪㼽蚪㼼蚪㼼蚪㼽蚪㼼蚪㼼蚪㼼蚪㼽蚪㼽蚪㼽蚪㼼蚪㼽蚪㼼蚪㼼蚪㼽蚪㼽蚪㼽蚪㼽蚪㼼蚪㼽蚪㼼蚪㼼蚪㼽蚪㼽蚪㼼蚪㼽蚪㼼蚪㼽蚪㼼蚪㼼蚪㼼蚪㼼蚪㼽蚪㼽蚪㼼蚪㼽蚪㼼蚪㼼蚪㼽蚪㼽蚪㼽蚪㼼蚪㼼蚪㼽蚪㼼蚪㼼蚪㼽蚪㼽蚪㼽蚪㼼蚪㼼蚪㼽蚪㼼蚪㼼蚪㼽蚪㼼蚪㼽蚪㼼蚪㼼蚪㼽蚪㼼蚪㼽蚪㼼蚪㼼蚪㼽蚪㼽蚪㼼蚪㼽蚪㼼蚪㼼蚪㼼蚪㼽蚪㼼蚪㼼蚪㼼蚪㼽蚪㼼蚪㼽蚪㼼蚪㼼蚪㼽蚪㼽蚪㼼蚪㼼蚪㼽蚪㼽蚪㼽蚪㼽蚪㼼蚪㼽蚪㼼蚪㼼蚪㼽蚪㼽蚪㼽蚪㼽蚪㼼蚪㼽蚪㼼蚪㼼蚪㼽蚪㼽蚪㼽蚪㼽蚪㼼蚪㼽'

```

It isn't.

Step 3: Check to see what options are left.

```python
set(c)
{134, 170, 60, 61, 63}

set(c[:8])
{134, 170, 60, 61, 63}

\x86\xaa?<
\x86\xaa?=
```

So we find that there are only a few characters being used and that there are two options. `\x86\xaa?<` and `\x86\xaa?=`

Step 4: Replace the binary encoding with binary `0` and `1`.

```python
#so now we can assume this encoding is binary..
d = c.replace(b'\x86\xaa?<', b'1').replace(b'\x86\xaa?=', b'0')
>>> d
b'1011001110110110101001011011100010100110110011001010110011001101101101001100101110100110101010111011000010101011101101011010110010111000101010011010100110111010110011011010110111001101101011001011000010111101101011011011100011001101101001011011101110111000101101011010100110110010101110101100101110100101101010111011110010110001101101011011110110111011101111101010100010111101101011001011010110100101110010111010100010110100101010001011110010111100101110001011110110111000101010101011001010110000101111011010111010110101101010011010100110111000101100001011001010111100101100011011000110110101101011001011101110101100110000101100001011000010'

#maybe dit dah, but...
len(d)
640
```

Step 5: Convert to ASCII.

```python
[chr(int(d[i*8:i*8+8],2)) for i in range(640//8)]
['³', '¶', '¥', '¸', '¦', 'Ì', '¬', 'Í', '´', 'Ë', '¦', '«', '°', '«', 'µ', '¬', '¸', '©', '©', 'º', 'Í', '\xad', 'Í', '¬', '°', '½', '\xad', '¸', 'Í', '¥', '»', '¸', 'µ', '©', '²', 'º', 'Ë', '¥', '«', '¼', '±', 'µ', '½', '»', '¾', '¨', '½', '¬', 'µ', '¥', 'Ë', '¨', '´', '¨', '¼', '¼', '¸', '½', '¸', 'ª', '²', '°', '½', '®', 'µ', '©', '©', '¸', '°', '²', '¼', '±', '±', 'µ', '¬', '»', '¬', 'Â', 'Â', 'Â']

#not quite

[chr(int(d[i*8:i*8+8],2)^128) for i in range(640//8)]
['3', '6', '%', '8', '&', 'L', ',', 'M', '4', 'K', '&', '+', '0', '+', '5', ',', '8', ')', ')', ':', 'M', '-', 'M', ',', '0', '=', '-', '8', 'M', '%', ';', '8', '5', ')', '2', ':', 'K', '%', '+', '<', '1', '5', '=', ';', '>', '(', '=', ',', '5', '%', 'K', '(', '4', '(', '<', '<', '8', '=', '8', '*', '2', '0', '=', '.', '5', ')', ')', '8', '0', '2', '<', '1', '1', '5', ',', ';', ',', 'B', 'B', 'B']

#maybe we can xor ff.
[chr(int(d[i*8:i*8+8],2)^255) for i in range(640//8)]
['L', 'I', 'Z', 'G', 'Y', '3', 'S', '2', 'K', '4', 'Y', 'T', 'O', 'T', 'J', 'S', 'G', 'V', 'V', 'E', '2', 'R', '2', 'S', 'O', 'B', 'R', 'G', '2', 'Z', 'D', 'G', 'J', 'V', 'M', 'E', '4', 'Z', 'T', 'C', 'N', 'J', 'B', 'D', 'A', 'W', 'B', 'S', 'J', 'Z', '4', 'W', 'K', 'W', 'C', 'C', 'G', 'B', 'G', 'U', 'M', 'O', 'B', 'Q', 'J', 'V', 'V', 'G', 'O', 'M', 'C', 'N', 'N', 'J', 'S', 'D', 'S', '=', '=', '=']
#yes we can

import binascii
binascii.a2b_base64(''.join([chr(int(d[i*8:i*8+8],2)^255) for i in range(640//8)]))
#Traceback (most recent call last):
#  File "<stdin>", line 1, in <module>
#binascii.Error: Invalid base64-encoded string: number of data characters (77) cannot be 1 more than a multiple of 4

```

Step 6: Base 32 Decode.

```python

# Probably base32
import base64
base64.b32decode(q)
b'Z2lnZW17M25jMGRpbmdfMXNfbjB0X2NyeXB0MF80Mjg0Mjd9'
```

Step 7: Base 64 Decode.

```python
binascii.a2b_base64(bb)
b'gigem{3nc0ding_1s_n0t_crypt0_428427}'

```
The flag is `gigem{3nc0ding_1s_n0t_crypt0_428427}`

